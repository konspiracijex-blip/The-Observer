<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>M4TR1X ARG - FINAL V48.8 (Agresivni Fiks za Mobilni Unos)</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script> 
    
    <style>
        /* (CSS STILOVI OSTALI NEPROMENJENI) */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%; 
            width: 100%;
            overflow: hidden;
            background-color: black;
            position: relative; 
        }
        
        :root {
            --vh: 1vh;
        }
        body {
            height: calc(var(--vh, 1vh) * 100); 
        }

        body {
            color: #00FF00; 
            font-family: 'Courier New', monospace;
            font-size: 1.2em; 
            cursor: default; 
            touch-action: manipulation;
            padding: 0; 
            margin: 0; 
            display: block; 
        }
        
        /* KRITIČNO: Postavljamo terminal div da je FOKUSABILAN */
        #terminal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0; 
            padding: 8px 20px 10px 20px; 
            white-space: pre-wrap;
            overflow-y: auto;
            outline: none; 
            transition: color 1s, background-color 1s;
            display: flex;
            flex-direction: column;
            /* Postavlja terminal da bude fokusabilan, što je ključ za mobilni input */
            -webkit-user-select: text; 
            user-select: text;
        }

        /* KRITIČNO: Zadržavamo 'input' logiku u terminalu za mobilne */
        #terminal:focus {
            outline: none; /* Uklanja ružan plavi fokus */
        }
        
        @media screen and (max-width: 600px) {
            #terminal {
                padding: 5px 10px 10px 10px;
            }
        }

        #output div {
            margin: 0; 
            padding: 0; 
            line-height: 1.2; 
            min-height: 0; 
        }

        #output > div:first-child {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        .shutdown {
            color: black !important;
            background-color: black !important;
        }
        
        /* SKRIVENI INPUT JE SADA UKLONJEN IZ HTML-a */
        
        .cursor {
            display: inline-block;
            width: 10px;
            height: 1.2em;
            background-color: #00FF00;
            vertical-align: text-bottom;
            animation: blinker 1s step-end infinite;
        }

        @keyframes blinker {
            from, to { opacity: 0; }
            50% { opacity: 1; }
        }

        #userInputDisplay {
            display: inline-block;
            min-width: 5px; 
        }

        #currentLine {
            display: flex; 
            align-items: baseline; 
            min-width: 100%; 
            display: none; 
        }
        
        #countdown {
            margin-top: 0; 
            color: #FFFF00; 
            font-weight: normal; 
            text-align: left; 
            padding-left: 0;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div id="terminal" tabindex="0">
        <div id="output">
        </div>
        <div id="currentLine">
            <span id="prompt"></span>
            <span id="userInputDisplay"></span>
            <span class="cursor" id="inputCursor"></span> 
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const terminalDiv = document.getElementById('terminal');
            const outputDiv = document.getElementById('output');
            const promptSpan = document.getElementById('prompt');
            const currentLineDiv = document.getElementById('currentLine'); 
            const userInputDisplay = document.getElementById('userInputDisplay');
            // hiddenInput je uklonjen, radimo samo sa promenljivama
            
            let inputActive = false; 
            let gamePhase = 1; 
            let currentInput = ""; 
            
            const CORRECT_LOGIN = "observer"; 
            
            // ... (Definicije nivoa ostaju iste) ...
            const RIDDLE_1_TEXT = "It’s the future, a shadow that stretches before you. You can sense it, feel its shape, but it never reveals itself - always just out of reach, always waiting.";
            const RIDDLE_1_ANSWER = "future"; 
            const RIDDLE_2_TEXT = "Keep your steps quiet as you move through the deserted streets.\nEvery shadow stretches, every whisper hides a secret.\nYou feel it, the hidden truth, just beyond perception - waiting for the one who notices.";
            const RIDDLE_2_ANSWER = "key"; 
            const RIDDLE_3_TEXT = "True power lies hidden in the text that everyone can read, where history meets secret societies. The pyramid on the seal conceals the moment when shadows first joined forces.\n\nFind it, study it carefully, and uncover the number.";
            const RIDDLE_3_ANSWER = "1776"; 
            const RIDDLE_4_TEXT = "An unfinished pyramid watches over the seal, silent and looming.\nEach layer tells a story, a hidden mark of power and order.\nThe original colonies lie beneath its shadow, whispered by the ancients.\n\nDiscover the number that connects the past to the secrets above.";
            const RIDDLE_4_ANSWER = "13"; 
            const RIDDLE_5_TEXT = "A message drifts through the static, a code hidden in dots and dashes.\nOnly those who listen carefully can hear what is whispered.\n\n... .... .- - --- .--";
            const RIDDLE_5_ANSWER = "shadow"; 
            const RIDDLE_6_TEXT = "Accessing restricted map layer...\nDecryption needed.\nLocation Hidden in Plain Sight:\n37.247456, -115.801709";
            const RIDiddle_6_ANSWERS = ["area 51", "area51"];
            const RIDDLE_7_TEXT = "Transmission intercepted...\nFilter the clutter. Extract only the hidden letters.\n\n#O%P#E*N^ #T&H#E# #A%R^C&H#I%V*E#";
            const RIDDLE_7_ANSWER = "open the archive";
            const RIDDLE_8_TEXT = "Signals scrambled. Digits mask the letters. \nEach number conceals a fragment of the truth. \nDecode carefully to reveal the hidden word.\n\n[SEQUENCE]: 13 1 20 18 9 24";
            const RIDDLE_8_ANSWER = "matrix";
            const RIDDLE_8_INCORRECT_MESSAGE = "INCORRECT. \nThe letters remain hidden. Re-evaluate the sequence."; 
            const RIDDLE_9_TEXT = "— TRANSMISSION INTERCEPTED —\nSignals scrambled. Numbers mask the letters.\nDecrypt the sequence to reveal the hidden word:\n\n67 79 78 83 80 73 82 65 67 89\n\nSubmit your answer to:\nkonspiracijex@gmail.com\n\nTRANSMISSION AWAITING\nKey not yet verified. \nStay alert. Further contact will follow after submission.\n//";
            const COUNTDOWN_TIME = 60; 
            const TYPEWRITER_TEXT = "Everywhere around you are visible walls, invisible locks. The world you live in is not the one you think you know. People sleep, believing what they’re told, not what they could discover themselves. So I ask you: are you an observer or a participant? Just another number in a system that uses you, or ready to uncover the truth within the matrix and pass through it? If you seek the truth, you must earn it. The doors open only to those who understand the hidden language.\n\nAre you ready? - YES / NO";
            const SHUTDOWN_MESSAGES = [
                { text: "System overload detected.", delay: 300, color: '#FFD700' }, 
                { text: "Forced termination imminent.", delay: 400, color: '#FFD700' },
                { text: "Closing network protocols...", delay: 200, color: '#FF0000' },
                { text: "Deactivating security matrix...", delay: 400 },
                { text: "All secure channels closing.", delay: 300 },
                { text: "UNMOUNTING HDD-WREN...", delay: 500 },
                { text: "CONNECTION TERMINATED.", delay: 1000, color: '#FF0000' }
            ];
            const BOOT_MESSAGES = [
                { text: "OBSERVER BIOS v4.51 (c) 1969 OBSERVER Systems Ltd.", delay: 100 }, 
                { text: "CPU: Intel i960GX Tactical (OK)", delay: 150 },
                { text: "Memory Test: Instruction Cache: 4 KB, Data Cache: 1 KB (Passed)", delay: 150 },
                { text: "Scanning for drives...", delay: 300 },
                { text: "HDD-WREN detected and mounted.", delay: 200 }, 
                { text: "Loading OS...", delay: 500 },
                { text: "Starting Kernel 2.1.99 - OBSERVER Secure Boot", delay: 200 },
                { text: "Initializing network protocols... [OK]", delay: 200 },
                { text: "Connecting to Gateway 01...", delay: 500 },
                { text: "System OBSERVER 2.1 Booted. Waiting for Authentication.", delay: 800, color: '#00FF00' } 
            ];

            // ... (Pomoćne funkcije ostaju iste) ...
            function clearScreen() { outputDiv.innerHTML = ''; }

            function outputText(text, isError = false, isCode = false, color = null) {
                const p = document.createElement('div');
                p.textContent = text;
                if (isError) {
                    p.style.color = '#FF0000'; 
                } else if (isCode) {
                    p.classList.add('code-block');
                } else if (color) {
                    p.style.color = color;
                }
                outputDiv.appendChild(p);
                terminalDiv.scrollTop = terminalDiv.scrollHeight; 
            }

            function typeWriter(text, speed = 8, callback) {
                const element = document.createElement('span'); 
                const container = document.createElement('div');
                container.appendChild(element);
                outputDiv.appendChild(container);
                terminalDiv.scrollTop = terminalDiv.scrollHeight;

                let i = 0;
                function type() {
                    if (i < text.length) {
                        if (text.charAt(i) === '\n') {
                            element.appendChild(document.createElement('br'));
                        } else {
                            element.innerHTML += text.charAt(i); 
                        }
                        i++;
                        setTimeout(type, speed);
                    } else if (callback) {
                        callback();
                    }
                }
                type();
            }

            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints > 0);
            }
            
            function setMobileHeight() {
                let vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                document.body.style.minHeight = `calc(var(--vh, 1vh) * 100)`;
            }
            
            setMobileHeight();
            window.addEventListener('resize', setMobileHeight);

            function shutdownSequence(isFinal = false) {
                inputActive = false;
                currentLineDiv.style.display = 'none';
                clearScreen();

                let delay = 0;
                SHUTDOWN_MESSAGES.forEach(msg => {
                    delay += msg.delay;
                    setTimeout(() => {
                        outputText(msg.text, false, false, msg.color);
                        if (msg === SHUTDOWN_MESSAGES[SHUTDOWN_MESSAGES.length - 1]) {
                            setTimeout(() => {
                                terminalDiv.classList.add('shutdown');
                                outputDiv.innerHTML = '';
                                terminalDiv.innerHTML = ''; 
                                
                                document.removeEventListener('keydown', keydownHandler);
                                terminalDiv.removeEventListener('click', clickHandler);
                                // input handler uklonjen
                            }, 500); 
                        }
                    }, delay);
                });
            }
            
            function startCountdownAndShutdown() {
                outputText(""); 
                outputText(""); 
                
                let countdownElement = document.getElementById('countdown');
                if (!countdownElement) {
                    countdownElement = document.createElement('div');
                    countdownElement.id = 'countdown';
                    outputDiv.appendChild(countdownElement);
                }
                
                let timeLeft = COUNTDOWN_TIME;
                
                const timerInterval = setInterval(() => {
                    if (timeLeft <= 0) {
                        clearInterval(timerInterval);
                        shutdownSequence(true); 
                        return;
                    }

                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    countdownElement.textContent = `SYSTEM SHUTDOWN IN: ${timeString}`;
                    
                    if (timeLeft <= 10) {
                        countdownElement.style.color = '#FF0000'; 
                    } else if (timeLeft <= 30) {
                        countdownElement.style.color = '#FFA500'; 
                    } else {
                        countdownElement.style.color = '#FFFF00'; 
                    }

                    timeLeft--;
                    terminalDiv.scrollTop = terminalDiv.scrollHeight;
                }, 1000);
            }

            function startBootSequence() {
                clearScreen(); 
                
                if (window.Telegram && window.Telegram.WebApp) {
                    window.Telegram.WebApp.ready();
                    window.Telegram.WebApp.MainButton.hide(); 
                }
                
                let delay = 0;
                BOOT_MESSAGES.forEach(msg => {
                    delay += msg.delay;
                    setTimeout(() => {
                        outputText(msg.text, false, false, msg.color);
                        if (msg === BOOT_MESSAGES[BOOT_MESSAGES.length - 1]) {
                            // KRITIČNO: Odlaganje fokusa za stabilnost
                            setTimeout(() => { activateInput(1); }, 100); 
                        }
                    }, delay);
                });
            }
            
            // ... (Ostale startLevelX funkcije ostaju iste) ...

            function activateInput(phase) {
                gamePhase = phase;
                if (phase === 1) promptSpan.textContent = "Login: ";
                // ... (ostali promptovi) ...
                if (phase === 2) promptSpan.textContent = ">> ";
                if (phase === 3) promptSpan.textContent = "Answer: "; 
                if (phase === 4) promptSpan.textContent = "Answer: "; 
                if (phase === 5) promptSpan.textContent = "Number: "; 
                if (phase === 6) promptSpan.textContent = "Number: "; 
                if (phase === 7) promptSpan.textContent = "Word: "; 
                if (phase === 8) promptSpan.textContent = "Answer: "; 
                if (phase === 9) promptSpan.textContent = "Key: "; 
                if (phase === 10) promptSpan.textContent = "Decode: "; 
                
                if (phase < 11) {
                    currentLineDiv.style.display = 'flex'; 
                    inputActive = true; 
                    currentInput = ""; // Reset input
                    userInputDisplay.textContent = "";
                    
                    // KRITIČNO: Fokusiramo SAMO terminal div
                    terminalDiv.focus(); 
                } else {
                    currentLineDiv.style.display = 'none';
                    inputActive = false;
                }
            }
            
            // ... (Handler funkcije ostaju iste) ...
            function handleLogin(input) {
                if (input === CORRECT_LOGIN) {
                    inputActive = false; currentLineDiv.style.display = 'none'; terminalDiv.classList.remove('shutdown');
                    clearScreen(); outputText("ACCESS GRANTED. Entering the system...", false);
                    setTimeout(startLevel2, 1500); 
                } else if (input.length > 0) {
                    outputText("Unknown user. Authentication failure.", true); 
                    activateInput(gamePhase); // Vraćamo unos
                } else {
                    outputText("Empty input. Try again.", true);
                    activateInput(gamePhase); // Vraćamo unos
                }
            }
            
            function handleYesNo(input) {
                if (input === 'yes') {
                    outputText("Truth acknowledged. Prepare for instruction.", false);
                    startLevel3(); 
                } else if (input === 'no') {
                    outputText("Choice declined. Shutting down system...", false);
                    shutdownSequence(); 
                } else {
                    outputText(`Invalid response: ${input.toUpperCase()}. Enter YES or NO.`, true);
                    activateInput(gamePhase); // Vraćamo unos
                }
            }
            
            // OVO JE KRITIČNO! U svim handleRiddleX funkcijama, u slučaju greške, morate
            // pozvati activateInput(gamePhase) da biste ponovo postavili fokus i prompt.

            const handleRiddleError = (msg) => {
                outputText(msg, true);
                activateInput(gamePhase);
            }
            
            function handleRiddle1(input) {
                if (input === RIDDLE_1_ANSWER) {
                    inputActive = false; currentLineDiv.style.display = 'none';
                    outputText("Well done!", false); outputText("Not everyone sees what you just uncovered.", false); outputText("Proceed with caution.", false);
                    setTimeout(() => { startLevel4(); }, 1500);
                } else {
                    handleRiddleError("Incorrect. Re-read the message and try again.");
                }
            }

            function handleRiddle2(input) {
                if (input === RIDDLE_2_ANSWER) {
                    inputActive = false; currentLineDiv.style.display = 'none';
                    outputText("ACCESS GRANTED.", false); outputText("KEY detected. Proceed.", false);
                    setTimeout(() => { startLevel5(); }, 1500);
                } else {
                    handleRiddleError("Incorrect. Re-read the message and try again.");
                }
            }
            
            // ... (Prilagodite sve ostale handleRiddleX funkcije da koriste handleRiddleError) ...
            
            function handleRiddle3(input) {
                if (input === RIDDLE_3_ANSWER) {
                    inputActive = false; currentLineDiv.style.display = 'none';
                    outputText("HISTORY ACKNOWLEDGED. The circle is complete.", false);
                    setTimeout(() => { startLevel6(); }, 1500);
                } else {
                    handleRiddleError("Incorrect. That number does not align with the hidden truth.");
                }
            }

            function handleRiddle4(input) {
                if (input === RIDDLE_4_ANSWER) {
                    inputActive = false; currentLineDiv.style.display = 'none';
                    outputText("THE COLONIES REMEMBER. The final layer is exposed.", false);
                    setTimeout(() => { startLevel7(); }, 1500);
                } else {
                    handleRiddleError("Incorrect. The past holds the key. Re-evaluate the layers.");
                }
            }

            function handleRiddle5(input) {
                if (input === RIDDLE_5_ANSWER) {
                    inputActive = false; currentLineDiv.style.display = 'none';
                    outputText("CODE BROKEN. Silence speaks volumes.", false);
                    setTimeout(() => { startLevel8(); }, 1500);
                } else {
                    handleRiddleError("Incorrect. Listen carefully to the static. Decode the message.");
                }
            }

            function handleRiddle6(input) {
                if (RIDiddle_6_ANSWERS.includes(input)) {
                    inputActive = false; currentLineDiv.style.display = 'none';
                    outputText("LOCATION CONFIRMED. The truth is out there.", false);
                    setTimeout(() => { startLevel9(); }, 1500);
                } else {
                    handleRiddleError("Incorrect. Decryption failed.");
                }
            }
            
            function handleRiddle7(input) {
                if (input === RIDDLE_7_ANSWER) {
                    inputActive = false; currentLineDiv.style.display = 'none';
                    outputText("ARCHIVE KEY ACCEPTED. Access granted to next layer.", false);
                    setTimeout(() => { startLevel10(); }, 1500);
                } else {
                    handleRiddleError("Incorrect. Filter the noise and check the transmission again.");
                }
            }
            
            function handleRiddle8(input) {
                if (input === RIDDLE_8_ANSWER) {
                    inputActive = false; currentLineDiv.style.display = 'none';
                    outputText("DECODING COMPLETE. The heart of the system je exposed.", false);
                    setTimeout(() => {
                        startLevel11_Final(); 
                    }, 1500);
                } else {
                    handleRiddleError(RIDDLE_8_INCORRECT_MESSAGE);
                }
            }
            
            const processInput = (fullInput) => {
                if (!inputActive) return; 
                
                if (fullInput === '') {
                     userInputDisplay.textContent = '';
                     currentInput = '';
                     return; 
                }
                
                const inputLower = fullInput.trim().toLowerCase();
                
                outputText(`${promptSpan.textContent}${fullInput}`);
                
                // Onemogućavamo unos dok se obrađuje
                inputActive = false; 

                if (gamePhase === 1) { handleLogin(inputLower); } 
                else if (gamePhase === 2) { handleYesNo(inputLower); } 
                else if (gamePhase === 3) { handleRiddle1(inputLower); } 
                else if (gamePhase === 4) { handleRiddle2(inputLower); } 
                else if (gamePhase === 5) { handleRiddle3(inputLower); } 
                else if (gamePhase === 6) { handleRiddle4(inputLower); } 
                else if (gamePhase === 7) { handleRiddle5(inputLower); } 
                else if (gamePhase === 8) { handleRiddle6(inputLower); } 
                else if (gamePhase === 9) { handleRiddle7(inputLower); } 
                else if (gamePhase === 10) { handleRiddle8(inputLower); } 

                // Ne resetujemo input ovde, već u activateInput da bismo osigurali stanje
            };
            
            // ***** KRITIČNA PROMENA RUKOVANJA DOGAĐAJIMA *****
            
            const keydownHandler = (e) => {
                if (!inputActive) return; 
                if (e.ctrlKey || e.altKey || e.metaKey) return; 
                
                if (e.key.length === 1 && e.key.match(/^[a-zA-Z0-9\s.,!?-]$/)) { 
                    e.preventDefault(); 
                    currentInput += e.key;
                    userInputDisplay.textContent = currentInput;
                } else if (e.key === 'Backspace') {
                    e.preventDefault(); 
                    currentInput = currentInput.slice(0, -1);
                    userInputDisplay.textContent = currentInput;
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    processInput(currentInput);
                }
                
                terminalDiv.scrollTop = terminalDiv.scrollHeight;
            };
            document.addEventListener('keydown', keydownHandler);


            // KRITIČNO: Rukovanje unosom na mobilnom, direktno u Terminal DIV
            // Ovo koristi činjenicu da kada je div fokusiran, kucanje ide u njega
            terminalDiv.addEventListener('input', (e) => {
                if (!inputActive || !isMobileDevice()) return;
                
                // Mobilni unosi često automatski pišu direktno u DIV ako je contenteditable, 
                // ali pošto nije, moramo ručno da rukujemo onim što kuca.
                // Na nekim telefonima će ovo kucati unutar DIV-a, što je OK za kratak unos.
                
                // Međutim, pošto mi koristimo `userInputDisplay` da prikažemo unos,
                // moramo da presretnemo unete karaktere.
                
                // Najbolji način da podržimo mobilni unos bez skrivenog inputa je
                // da se oslonimo na `keydown` i `input` događaje. Pošto kucanje 
                // u terminalDiv NE GENERIŠE `input` događaje, moramo da se 
                // oslonimo na jedini preostali mehanizam:
                
                // KLIK HANDLER mora AGRESIVNO da vrati fokus na DIV

            });

            const clickHandler = (e) => {
                if (!inputActive) return; 
                e.preventDefault(); 
                // Fokusiranje DIV-a će u većini Web View okruženja izazvati tastaturu.
                terminalDiv.focus(); 
            };
            terminalDiv.addEventListener('click', clickHandler);
            
            
            // KRITIČNA DODATNA PROVERA ZA Android/Chrome/Telegram:
            // Slušamo 'beforeinput' događaj na DIV-u da bismo uhvatili kucanje 
            // koje ne generiše 'keydown' kod.
            terminalDiv.addEventListener('beforeinput', (e) => {
                if (!inputActive) return;

                if (e.inputType === 'insertText') {
                    e.preventDefault();
                    currentInput += e.data;
                    userInputDisplay.textContent = currentInput;
                } else if (e.inputType === 'deleteContentBackward') {
                    e.preventDefault();
                    currentInput = currentInput.slice(0, -1);
                    userInputDisplay.textContent = currentInput;
                } else if (e.inputType === 'insertLineBreak') {
                    e.preventDefault();
                    processInput(currentInput);
                }
                terminalDiv.scrollTop = terminalDiv.scrollHeight;
            });
            
            
            // KRITIČNA MERA: Omogućavamo Terminalu da prima kucanje
            // Dodajemo atribut `contenteditable` (iako ga posle gasimo)
            // U ovom kodu je to rešeno sa `user-select: text;` i `terminalDiv.focus()`
            
            startBootSequence();
        });
    </script>
</body>
</html>
